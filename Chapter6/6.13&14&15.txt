练习6.13
假设T是某种类型的名字，说明以下两个函数声明的区别： 一个是void f(T), 另一个是void f(&T)。
解：
void f(T)的参数通过值传递，在函数中T是实参的副本，改变T不会影响到原来的实参。 
void f(&T)的参数通过引用传递，在函数中的T是实参的引用，T的改变也就是实参的改变。

练习6.14
举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。
解：
例如交换两个整数的函数，形参应该是引用
void swap(int& lhs, int& rhs)
{
	int temp = lhs;
	lhs = rhs;
	rhs = temp;
}
当实参的值是右值时，形参不能为引用类型

int add(int a, int b)
{
	return a + b;
}

int main()
{
	int i = add(1,2);
	return 0;
}

练习6.15
说明find_char函数中的三个形参为什么是现在的类型，特别说明为什么s是常量引用而occurs是普通引用？ 
为什么s和occurs是引用类型而c不是？ 如果令s是普通引用会发生什么情况？ 如果令occurs是常量引用会发生什么情况？

解：
因为字符串可能很长，因此使用引用避免拷贝；而在函数中我们不希望改变s的内容，所以令s为常量。
occurs是要传到函数外部的变量，所以使用引用，occurs的值会改变，所以是普通引用。
因为我们只需要c的值，这个实参可能是右值(右值实参无法用于引用形参)，所以c不能用引用类型。
如果s是普通引用，也可能会意外改变原来字符串的内容。occurs如果是常量引用，那么意味着不能改变它的值，那也就失去意义了。
