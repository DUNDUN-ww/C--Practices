2.15：
(a) int ival = 1.01;   //合法
(b) int &rval1 = 1.01; //非法，引用必须指向一个实际存在的对象（相当于起外号）

(c) int &rval2 = ival;   //合法 
(d) int  &rval3;        //非法，无法令引用重新绑定到另外一个对象上，引用必须初始化

 
 2.16
int i = 0, &r1 = i;               
double d = 0, &r2 = d;
(a) r2 = 3.14159;    //非法的，为引用赋值实际上是把值赋给了与引用绑定的对象，在这里是把3.14159赋给了变量d。         
(b) r2 = r1;         //合法的，以引用作为初始值实际上是以引用绑定的对象作为初始值，在这里把i的值嵌给了变量d。
(c) i = r2;          //合法的，把d的值赋给了变量i,因为d是双精度浮点数而i是整数，所以该语句实际上执行了窄化操作。
(d) r1 = d;          //是合法的，把d的值赋给了变量i，与上一条语句一样执行了窄化操作。

2.17:
int i = 0, &ri = i;                
i = 5; 
ri = 10;
std::cout << i << "  " << ri << std::endl;

A：输出结果是 10  10.
引用不是对象，它只是为已经存在的对象起了另外一个名字，因此ri实际上是i的别名。
在上述程序中，首先将i赋值为5，然后把这个值更新为10。因为ri是i的引用，所以它们的输出结果一样都是。
